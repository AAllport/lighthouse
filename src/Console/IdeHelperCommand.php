<?php

namespace Nuwave\Lighthouse\Console;

use Illuminate\Console\Command;
use HaydenPierce\ClassFinder\ClassFinder;
use Nuwave\Lighthouse\Schema\AST\PartialParser;
use Nuwave\Lighthouse\Schema\DirectiveNamespaces;
use Nuwave\Lighthouse\Support\Contracts\Directive;
use Nuwave\Lighthouse\Support\Contracts\DefinedDirective;

class IdeHelperCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'lighthouse:ide-helper';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Gather all schema directive definitions and print the result.';

    /**
     * Execute the console command.
     *
     * @param  \Nuwave\Lighthouse\Schema\DirectiveNamespaces  $directiveNamespaces
     * @return int
     */
    public function handle(DirectiveNamespaces $directiveNamespaces): int
    {
        if (! class_exists('HaydenPierce\ClassFinder\ClassFinder')) {
            $this->error(
                "This command requires haydenpierce/class-finder. Install it by running:\n"
                ."\n"
                ."    composer require --dev haydenpierce/class-finder\n"
                ."\n"
            );

            return 1;
        }

        $directiveClasses = $this->scanForDirectives(
            $directiveNamespaces->gather()
        );

        $schema = $this->buildSchemaString($directiveClasses);

        $fileName = base_path().'/schema-directives.graphql';
        file_put_contents($fileName, $schema);

        $this->info("Wrote schema directive definitions to $fileName.");
    }

    protected function define(string $name, string $directiveClass): string
    {
        if (is_a($directiveClass, DefinedDirective::class)) {
            /** @var DefinedDirective $directiveClass */
            $definition = $directiveClass::definition();

            // This operation throws if the schema definition is invalid
            PartialParser::directiveDefinition($definition);

            return trim($definition);
        } else {
            return '# Add a proper definition by implementing '.DefinedDirective::class."\n"
                ."directive @{$name}";
        }
    }

    /**
     * Scan the given namespaces for directive classes.
     *
     * @param  string[]  $directiveNamespaces
     * @return string[]
     */
    protected function scanForDirectives(array $directiveNamespaces): array
    {
        $directives = [];

        foreach ($directiveNamespaces as $directiveNamespace) {
            foreach (ClassFinder::getClassesInNamespace($directiveNamespace) as $class) {
                $reflection = new \ReflectionClass($class);
                if (! $reflection->isInstantiable()) {
                    continue;
                }

                if (! is_a($class, Directive::class)) {
                    continue;
                }

                /** @var \Nuwave\Lighthouse\Support\Contracts\Directive $instance */
                $instance = app($class);
                $name = $instance->name();

                // The directive was already found, so we do not add it twice
                if (isset($directives[$name])) {
                    continue;
                }

                $directives[$name] = $class;
            }
        }

        return $directives;
    }

    /**
     * @param string[] $directiveClasses
     * @return string
     */
    protected function buildSchemaString(array $directiveClasses): string
    {
        $schema = '# File generated by "php artisan lighthouse:ide-helper".
# Do not edit this file directly.
# This file should be ignored by git.';

        foreach ($directiveClasses as $name => $directiveClass) {
            $definition = $this->define($name, $directiveClass);

            $schema .= "\n"
                ."# Directive class: $directiveClass\n"
                .$definition;
        }

        return $schema;
    }
}
